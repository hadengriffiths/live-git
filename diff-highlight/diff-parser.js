var diff = "--- a/python-client/git_helpers.py\n+++ b/python-client/git_helpers.py\n@@ -1,12 +1,19 @@\n #!/usr/bin/env python\n \"\"\"\n-\n+Scripts for retrieving data about the git repository\n \"\"\"\n \n from git import *\n import os, sys\n \n def get_info():\n+    \"\"\"\n+    Returns:\n+        A single dict with keys:\n+            computer\n+            workingCopy\n+    \"\"\"\n+\n     # Scripting part (move into main() etc functions later)\n     cwd = os.getcwd()\n     git_directory = os.path.join(os.getcwd() + \"/.git/\")\n@@ -36,47 +43,38 @@ def get_info():\n \n     results[\"computer\"] = computer\n \n-    # Branch \n+    # Gather branch information\n     current_branch = repo.active_branch\n     untracked = repo.untracked_files\n \n-    # Remotes\n-    raw_remotes = repo.remotes\n+    # In order to make sure that we have up to date information, we fetch\n+    origin_remote = next((r for r in repo.remotes if r.name == 'origin'), None)\n+    if not origin_remote:\n+        print \"This tool requires a remote branch named 'origin'\"\n+        sys.exit(1)\n+\n+    origin_remote.fetch()\n+\n+    # Gather information about unpushed commits\n+    unpushed_commits = {}\n+\n+    raw_unpushed_str = repo.git.log(\"origin/%s..HEAD\" % current_branch.name)\n+    unpushed_hexshas = [line.split(\" \")[1] for line in raw_unpushed_str.split('\\n') \n+            if line.startswith(\"commit\")]\n+    unpushed_objs = [repo.commit(h) for h in unpushed_hexshas]\n+\n+    previous_commit = None # The first commit to diff should be the last committed to the remote\n+    unpushed_commits = []\n+    for u in unpushed_objs:\n+        unpushed_commits.append(commit_to_dict(u, previous_commit))\n+        previous_commit = u\n \n     # Information about the commits on that branch\n     # Grab the commits in reverse chronological order\n     commits = []\n     previous_commit = None  # Find diff relative to previous commit\n     for c in repo.iter_commits():\n-        current_diffs = c.diff(previous_commit, create_patch=True)\n-        changed_files = [d.a_blob.name for d in current_diffs]\n-        detailed_diffs = []\n-\n-        for diff in current_diffs:\n-            # For now, ignore renamed, deleted\n-            if diff.deleted_file or diff.renamed:\n-                continue\n-            # TODO exclude binary files (like images)\n-\n-            # We can take a or b for the two diffs: \n-            # take b, since new files don't have an a_blob\n-            filename = d.b_blob.name  \n-            detailed_diffs.append({\n-                \"filename\": filename, \n-                \"content\": diff.diff }\n-                )\n-\n-        commit_info = {\n-                \"hash\": c.hexsha,\n-                \"author\": {\n-                    \"name\": c.author.name,\n-                    \"email\": c.author.email\n-                },\n-                \"message\": c.message,\n-                \"timestamp\": c.committed_date,\n-                \"files\": changed_files\n-        }\n-\n+        commit_info = commit_to_dict(c, previous_commit)\n         commits.append(commit_info)\n         previous_commit = c\n \n@@ -84,10 +82,57 @@ def get_info():\n             \"timestamp\": \"TODO\",  # TODO record last time sent from client\n             \"branchName\": current_branch.name,\n             \"untrackedFiles\": untracked,\n+            \"unpushedCommits\": unpushed_commits,\n             \"commits\": commits,\n             \"clientDir\": cwd\n     }\n \n     results[\"workingCopy\"] = working_copy\n \n-    print results\n+    return results\n+\n+def commit_to_dict(c, previous_commit=None):\n+    \"\"\" \n+    Converts a commit object to a dict that we can send to the server i\n+\n+    Args: \n+        c: pygit2 commit object\n+        previous_commit: another pygit2 commit object, used\n+            to find a diff\n+    \"\"\"\n+    current_diffs = c.diff(previous_commit, create_patch=True)\n+    changed_files = [d.a_blob.name for d in current_diffs]\n+    detailed_diffs = []\n+\n+    for diff in current_diffs:\n+        # For now, ignore renamed, deleted files from detailed_diffs\n+        if diff.deleted_file or diff.renamed:\n+            continue\n+\n+        # We can take a or b for the two diffs: \n+        # take b, since new files don't have an a_blob\n+        filename = d.b_blob.name  \n+        detailed_diffs.append({\n+            \"filename\": filename, \n+            \"content\": diff.diff }\n+            )\n+\n+    commit_info = {\n+            \"hash\": c.hexsha,\n+            \"author\": {\n+                \"name\": c.author.name,\n+                \"email\": c.author.email\n+            },\n+            \"message\": c.message,\n+            \"timestamp\": c.committed_date,\n+            \"files\": changed_files,\n+            \"diff\": detailed_diffs\n+    }\n+    return commit_info\n+\n+\n+if __name__ == '__main__':\n+    get_info()\n+    import json\n+    print json.dumps(get_info())\n+\n";

if (Meteor.isClient) {
  Template.test.diff = function () {
    return diff;
  };

  Template.test.events({
    'click input' : function () {
      console.log("You pressed the button");

      hljs.highlightBlock(document.getElementById("foobar"));
    }
  });
}

if (Meteor.isServer) {
  Meteor.startup(function () {
    // code to run on server at startup
  });
}
